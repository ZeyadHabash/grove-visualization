<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Grove's System of Spheres Visualization</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 20px;
        max-width: 1000px;
        margin: 0 auto;
      }
      .container {
        display: flex;
        flex-direction: row;
        gap: 20px;
      }
      .controls {
        width: 300px;
        padding: 10px;
        border: 1px solid #ccc;
        border-radius: 5px;
      }
      .visualization {
        flex-grow: 1;
        border: 1px solid #ccc;
        border-radius: 5px;
        position: relative;
      }
      canvas {
        display: block;
      }
      label {
        display: block;
        margin-top: 10px;
        margin-bottom: 5px;
        font-weight: bold;
      }
      input,
      select {
        margin-bottom: 15px;
        width: 100%;
      }
      button {
        background-color: #4caf50;
        border: none;
        color: white;
        padding: 10px 15px;
        text-align: center;
        text-decoration: none;
        display: inline-block;
        font-size: 16px;
        margin: 4px 2px;
        cursor: pointer;
        border-radius: 4px;
      }
      .info-panel {
        margin-top: 20px;
        padding: 10px;
        background-color: #f8f9fa;
        border-radius: 5px;
      }
      .proposition {
        margin-bottom: 10px;
        padding: 5px;
        background-color: #e9ecef;
        border-radius: 3px;
      }
      .help-text {
        margin-top: 15px;
        font-style: italic;
        font-size: 0.9em;
        color: #666;
      }
    </style>
    <style>
      /* Add after other styles */
      .math-notation {
        font-family: "Times New Roman", serif;
        font-style: italic;
      }

      .sphere-label {
        position: absolute;
        background: rgba(255, 255, 255, 0.7);
        padding: 3px;
        border-radius: 3px;
        pointer-events: none;
      }

      .example-panel {
        margin-top: 15px;
        padding: 10px;
        border: 1px solid #ddd;
        border-radius: 5px;
      }

      .example-button {
        background-color: #4b76c5;
        margin-right: 5px;
      }

      .postulate {
        background-color: #f8f9fa;
        padding: 8px;
        margin-bottom: 5px;
        border-left: 3px solid #4caf50;
      }

      #tutorial-panel {
        position: absolute;
        bottom: 10px;
        right: 10px;
        background: rgba(255, 255, 255, 0.9);
        border: 1px solid #ccc;
        padding: 10px;
        border-radius: 5px;
        max-width: 300px;
        display: none;
      }
    </style>
  </head>
  <body>
    <h1>Grove's System of Spheres Visualization</h1>
    <p>
      Interact with this visualization to understand how Grove's system of
      spheres models belief revision.
    </p>

    <div class="container">
      <div class="controls">
        <h2>Controls</h2>

        <label for="num-spheres">Number of Spheres:</label>
        <input type="range" id="num-spheres" min="2" max="7" value="4" />

        <label for="proposition">Define Proposition:</label>
        <select id="proposition-shape">
          <option value="circle">Circle</option>
          <option value="rectangle">Rectangle</option>
          <option value="polygon">Polygon</option>
        </select>

        <div id="proposition-params">
          <!-- Will be populated dynamically -->
        </div>

        <button id="add-proposition">Add Proposition</button>
        <button id="clear-propositions">Clear Propositions</button>

        <div class="proposition-list">
          <h3>Defined Propositions</h3>
          <div id="propositions"></div>
        </div>

        <div class="revision-controls">
          <h3>Revision</h3>
          <label for="revision-prop">Revise with proposition:</label>
          <select id="revision-prop">
            <option value="">Select a proposition</option>
          </select>
          <button id="perform-revision">Perform Revision</button>
          <button id="reset-revision">Reset</button>
        </div>
      </div>

      <div class="visualization">
        <canvas id="canvas" width="600" height="600"></canvas>

        <div class="info-panel">
          <h3>Information</h3>
          <div id="info-content">
            <p>
              Current theory T is represented by the innermost sphere (|T|).
            </p>
            <p>
              Add propositions and perform revisions to see how Grove's model
              works.
            </p>
          </div>
        </div>
      </div>
      <div class="example-panel">
        <h3>Example Scenarios</h3>
        <p>Click an example to see Grove's model in action:</p>
        <button class="example-button" id="example-consistency">
          Consistent Revision
        </button>
        <button class="example-button" id="example-minimal-change">
          Minimal Change
        </button>
        <button class="example-button" id="example-success">
          Success Postulate
        </button>
        <button class="example-button" id="example-recovery">Recovery</button>
      </div>

      <div id="tutorial-panel">
        <h4>Tutorial</h4>
        <p id="tutorial-text">
          Welcome to Grove's System of Spheres visualization.
        </p>
        <button id="tutorial-next">Next</button>
        <button id="tutorial-close">Close</button>
      </div>
    </div>

    <div class="help-text">
      <h3>Understanding Grove's System of Spheres:</h3>
      <p>
        This visualization demonstrates Grove's theoretical framework for belief
        revision as described in his 1988 paper "Two Modellings for Theory
        Change".
      </p>

      <div class="postulate">
        <h4>Key Concepts:</h4>
        <ul>
          <li>The innermost sphere represents your current beliefs |T|</li>
          <li>Outer spheres represent increasingly less plausible worlds</li>
          <li>
            When revising with proposition A, we find c(A): the smallest sphere
            intersecting |A|
          </li>
          <li>The revised belief T+A = t(|A| ∩ c(A))</li>
        </ul>
      </div>

      <h4>AGM Postulates Demonstrated:</h4>
      <div class="postulate">
        <strong>(+1) Closure:</strong> The revised theory T+A is logically
        closed
        <p class="math-notation">
          Formal: T+A = Cn(T+A), where Cn is the logical closure operator
        </p>
      </div>
      <div class="postulate">
        <strong>(+2) Success:</strong> When revising with A, the proposition A
        is included in the revised theory
        <p class="math-notation">Formal: A ∈ T+A</p>
      </div>
      <div class="postulate">
        <strong>(+3) Expansion:</strong> If A is consistent with T, then T+A =
        T∪{A}
        <p class="math-notation">Formal: If ¬A ∉ T, then T+A = Cn(T ∪ {A})</p>
      </div>
      <div class="postulate">
        <strong>(+4) Consistency:</strong> T+A is consistent if A is consistent
        <p class="math-notation">
          Formal: If ¬A is not a tautology, then T+A is consistent
        </p>
      </div>
      <div class="postulate">
        <strong>(+5) Preservation:</strong> If A and B are logically equivalent,
        then T+A = T+B
        <p class="math-notation">Formal: If ⊢ A ↔ B, then T+A = T+B</p>
      </div>
      <div class="postulate">
        <strong>(+6) Recovery:</strong> The intersection of the revised theory
        with the original theory equals the contraction of ¬A from T
        <p class="math-notation">Formal: T ⊆ (T-A)+A</p>
      </div>
      <div class="postulate">
        <strong>(+7) Conjunctive Inclusion:</strong> T+(A∧B) ⊆ (T+A)+B
        <p class="math-notation">Formal: T+(A∧B) ⊆ (T+A)+B</p>
      </div>
      <div class="postulate">
        <strong>(+8) Conjunctive Vacuity:</strong> If ¬B ∉ T+A, then (T+A)+B ⊆
        T+(A∧B)
        <p class="math-notation">Formal: If ¬B ∉ T+A, then (T+A)+B ⊆ T+(A∧B)</p>
      </div>
    </div>

    <script>
      // Constants
      const CANVAS_WIDTH = 600;
      const CANVAS_HEIGHT = 600;
      const CENTER_X = CANVAS_WIDTH / 2;
      const CENTER_Y = CANVAS_HEIGHT / 2;
      const MAX_RADIUS = Math.min(CENTER_X, CENTER_Y) * 0.9;

      // State
      let numSpheres = 4;
      let propositions = [];
      let selectedProposition = null;
      let revisionResult = null;
      let revisionStep = 0; // 0: None, 1: Show c(A), 2: Show fs(A), 3: Show final result

      // Colors
      const sphereColors = [
        "rgba(200, 230, 255, 0.5)", // Innermost sphere
        "rgba(180, 220, 255, 0.4)",
        "rgba(160, 210, 255, 0.3)",
        "rgba(140, 200, 255, 0.25)",
        "rgba(120, 190, 255, 0.2)",
        "rgba(100, 180, 255, 0.15)",
        "rgba(80, 170, 255, 0.1)", // Outermost sphere
      ];

      // Get DOM elements
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");
      const numSpheresInput = document.getElementById("num-spheres");
      const propositionShapeSelect =
        document.getElementById("proposition-shape");
      const propositionParamsDiv =
        document.getElementById("proposition-params");
      const addPropositionButton = document.getElementById("add-proposition");
      const clearPropositionsButton =
        document.getElementById("clear-propositions");
      const propositionsList = document.getElementById("propositions");
      const revisionPropSelect = document.getElementById("revision-prop");
      const performRevisionButton = document.getElementById("perform-revision");
      const resetRevisionButton = document.getElementById("reset-revision");
      const infoContent = document.getElementById("info-content");

      // Initialize
      function init() {
        // Set up event listeners
        numSpheresInput.addEventListener("input", () => {
          numSpheres = parseInt(numSpheresInput.value);
          draw();
        });

        propositionShapeSelect.addEventListener(
          "change",
          updatePropositionParams
        );

        addPropositionButton.addEventListener("click", addProposition);
        clearPropositionsButton.addEventListener("click", clearPropositions);

        performRevisionButton.addEventListener("click", performRevision);
        resetRevisionButton.addEventListener("click", resetRevision);

        // Initial setup
        updatePropositionParams();
        draw();
      }

      // Update proposition parameters based on selected shape
      function updatePropositionParams() {
        const shape = propositionShapeSelect.value;
        let html = "";

        html += '<label for="prop-name">Name (e.g., A, B, C):</label>';
        html +=
          '<input type="text" id="prop-name" placeholder="A" maxlength="1" required>';

        switch (shape) {
          case "circle":
            html += '<label for="prop-x">Center X (0-100):</label>';
            html +=
              '<input type="number" id="prop-x" min="0" max="100" value="70">';
            html += '<label for="prop-y">Center Y (0-100):</label>';
            html +=
              '<input type="number" id="prop-y" min="0" max="100" value="50">';
            html += '<label for="prop-radius">Radius (5-40):</label>';
            html +=
              '<input type="number" id="prop-radius" min="5" max="40" value="20">';
            break;

          case "rectangle":
            html += '<label for="prop-x">Left (0-100):</label>';
            html +=
              '<input type="number" id="prop-x" min="0" max="100" value="60">';
            html += '<label for="prop-y">Top (0-100):</label>';
            html +=
              '<input type="number" id="prop-y" min="0" max="100" value="30">';
            html += '<label for="prop-width">Width (10-80):</label>';
            html +=
              '<input type="number" id="prop-width" min="10" max="80" value="30">';
            html += '<label for="prop-height">Height (10-80):</label>';
            html +=
              '<input type="number" id="prop-height" min="10" max="80" value="40">';
            break;

          case "polygon":
            html += "<label>Position (0-100 scale):</label>";
            html += '<div style="display: flex; gap: 5px;">';
            html +=
              '<input type="number" id="prop-x1" placeholder="X1" min="0" max="100" value="50">';
            html +=
              '<input type="number" id="prop-y1" placeholder="Y1" min="0" max="100" value="20">';
            html += "</div>";
            html += '<div style="display: flex; gap: 5px;">';
            html +=
              '<input type="number" id="prop-x2" placeholder="X2" min="0" max="100" value="70">';
            html +=
              '<input type="number" id="prop-y2" placeholder="Y2" min="0" max="100" value="50">';
            html += "</div>";
            html += '<div style="display: flex; gap: 5px;">';
            html +=
              '<input type="number" id="prop-x3" placeholder="X3" min="0" max="100" value="40">';
            html +=
              '<input type="number" id="prop-y3" placeholder="Y3" min="0" max="100" value="70">';
            html += "</div>";
            break;
        }

        propositionParamsDiv.innerHTML = html;
      }

      // Add a new proposition
      function addProposition() {
        const nameInput = document.getElementById("prop-name");
        const name = nameInput.value.trim().toUpperCase();

        if (!name) {
          alert("Please enter a name for the proposition.");
          return;
        }

        // Check for duplicate names
        if (propositions.some((p) => p.name === name)) {
          alert(`Proposition "${name}" already exists.`);
          return;
        }

        const shape = propositionShapeSelect.value;
        let proposition = { name, shape, color: getRandomColor() };

        switch (shape) {
          case "circle":
            proposition.x =
              (parseInt(document.getElementById("prop-x").value) / 100) *
              CANVAS_WIDTH;
            proposition.y =
              (parseInt(document.getElementById("prop-y").value) / 100) *
              CANVAS_HEIGHT;
            proposition.radius =
              (parseInt(document.getElementById("prop-radius").value) / 100) *
              MAX_RADIUS *
              2;
            break;

          case "rectangle":
            proposition.x =
              (parseInt(document.getElementById("prop-x").value) / 100) *
              CANVAS_WIDTH;
            proposition.y =
              (parseInt(document.getElementById("prop-y").value) / 100) *
              CANVAS_HEIGHT;
            proposition.width =
              (parseInt(document.getElementById("prop-width").value) / 100) *
              CANVAS_WIDTH;
            proposition.height =
              (parseInt(document.getElementById("prop-height").value) / 100) *
              CANVAS_HEIGHT;
            break;

          case "polygon":
            proposition.points = [
              {
                x:
                  (parseInt(document.getElementById("prop-x1").value) / 100) *
                  CANVAS_WIDTH,
                y:
                  (parseInt(document.getElementById("prop-y1").value) / 100) *
                  CANVAS_HEIGHT,
              },
              {
                x:
                  (parseInt(document.getElementById("prop-x2").value) / 100) *
                  CANVAS_WIDTH,
                y:
                  (parseInt(document.getElementById("prop-y2").value) / 100) *
                  CANVAS_HEIGHT,
              },
              {
                x:
                  (parseInt(document.getElementById("prop-x3").value) / 100) *
                  CANVAS_WIDTH,
                y:
                  (parseInt(document.getElementById("prop-y3").value) / 100) *
                  CANVAS_HEIGHT,
              },
            ];
            break;
        }

        propositions.push(proposition);
        updatePropositionsList();
        updateRevisionSelect();
        draw();
      }

      // Clear all propositions
      function clearPropositions() {
        propositions = [];
        resetRevision();
        updatePropositionsList();
        updateRevisionSelect();
        draw();
      }

      // Update the list of propositions displayed
      function updatePropositionsList() {
        let html = "";

        if (propositions.length === 0) {
          html = "<p>No propositions defined yet.</p>";
        } else {
          propositions.forEach((prop) => {
            html += `<div class="proposition" style="border-left: 4px solid ${prop.color}">`;
            html += `<strong>${prop.name}</strong>: ${prop.shape}`;
            html += "</div>";
          });
        }

        propositionsList.innerHTML = html;
      }

      // Update the revision proposition select dropdown
      function updateRevisionSelect() {
        let html = '<option value="">Select a proposition</option>';

        propositions.forEach((prop) => {
          html += `<option value="${prop.name}">${prop.name}</option>`;
        });

        revisionPropSelect.innerHTML = html;
      }

      // Perform revision with selected proposition
      function performRevision() {
        const selectedName = revisionPropSelect.value;
        if (!selectedName) {
          alert("Please select a proposition to revise with.");
          return;
        }

        selectedProposition = propositions.find((p) => p.name === selectedName);
        revisionStep = 1;
        calculateRevision();
        draw();
        updateInfo();
      }

      // Calculate the result of revision
      function calculateRevision() {
        // Find the smallest sphere that intersects with the proposition
        let sphereIndex = -1;

        // Check each sphere starting from the innermost
        for (let i = 0; i < numSpheres; i++) {
          const sphereRadius = (i + 1) * (MAX_RADIUS / numSpheres);
          if (doesShapeIntersectSphere(selectedProposition, sphereRadius)) {
            sphereIndex = i;
            break;
          }
        }

        revisionResult = {
          proposition: selectedProposition,
          sphereIndex: sphereIndex,
        };
      }

      // Check if a shape intersects with a sphere
      function doesShapeIntersectSphere(shape, sphereRadius) {
        switch (shape.shape) {
          case "circle":
            // Calculate the distance between circle centers
            const dx = shape.x - CENTER_X;
            const dy = shape.y - CENTER_Y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            // Circle-circle intersection: if distance between centers is <= sum of radii
            return distance <= sphereRadius + shape.radius;

          case "rectangle":
            // Check if any corner of the rectangle is inside the sphere
            const corners = [
              { x: shape.x, y: shape.y },
              { x: shape.x + shape.width, y: shape.y },
              { x: shape.x, y: shape.y + shape.height },
              { x: shape.x + shape.width, y: shape.y + shape.height },
            ];

            for (const corner of corners) {
              const dx = corner.x - CENTER_X;
              const dy = corner.y - CENTER_Y;
              const distance = Math.sqrt(dx * dx + dy * dy);
              if (distance <= sphereRadius) {
                return true;
              }
            }

            // Also check if the sphere intersects any edge of the rectangle
            // (Simplified approximation for visualization purposes)
            const closestX = Math.max(
              shape.x,
              Math.min(CENTER_X, shape.x + shape.width)
            );
            const closestY = Math.max(
              shape.y,
              Math.min(CENTER_Y, shape.y + shape.height)
            );
            const rectDx = closestX - CENTER_X;
            const rectDy = closestY - CENTER_Y;
            const rectDistance = Math.sqrt(rectDx * rectDx + rectDy * rectDy);
            return rectDistance <= sphereRadius;

          case "polygon":
            // Check if any point of the polygon is inside the sphere
            for (const point of shape.points) {
              const polyDx = point.x - CENTER_X;
              const polyDy = point.y - CENTER_Y;
              const polyDistance = Math.sqrt(polyDx * polyDx + polyDy * polyDy);
              if (polyDistance <= sphereRadius) {
                return true;
              }
            }

            // Check if any edge of the polygon intersects with the sphere
            for (let i = 0; i < shape.points.length; i++) {
              const p1 = shape.points[i];
              const p2 = shape.points[(i + 1) % shape.points.length];

              // Calculate closest point on line segment to circle center
              const dx = p2.x - p1.x;
              const dy = p2.y - p1.y;
              const lengthSquared = dx * dx + dy * dy;

              if (lengthSquared === 0) continue;

              const t = Math.max(
                0,
                Math.min(
                  1,
                  ((CENTER_X - p1.x) * dx + (CENTER_Y - p1.y) * dy) /
                    lengthSquared
                )
              );

              const closestX = p1.x + t * dx;
              const closestY = p1.y + t * dy;

              const distX = closestX - CENTER_X;
              const distY = closestY - CENTER_Y;
              const distance = Math.sqrt(distX * distX + distY * distY);

              if (distance <= sphereRadius) {
                return true;
              }
            }

            return false;
        }

        return false;
      }
      function validateAGMPostulates(originalT, proposition, revisedT) {
        const info = [];

        // Closure postulate: The revised theory is logically closed
        info.push({
          postulate: "(+1) Closure",
          satisfied: "Yes",
          explanation:
            "The revised theory T+A is logically closed because we take all sentences true in the selected worlds",
          formal: "T+A = Cn(T+A), where Cn is the logical closure operator",
        });

        // Success postulate: proposition should be in revised theory
        info.push({
          postulate: "(+2) Success",
          satisfied: "The new proposition is included in the revised theory",
          explanation:
            "This is guaranteed by selecting worlds where the proposition is true",
          formal: "A ∈ T+A",
        });

        // Expansion: If proposition is consistent with T, T+A = T∪{A}
        const isConsistentWithT = doesShapeIntersectSphere(
          proposition,
          MAX_RADIUS / numSpheres
        );
        info.push({
          postulate: "(+3) Expansion",
          satisfied: isConsistentWithT ? "Yes" : "N/A",
          explanation: isConsistentWithT
            ? "The proposition is consistent with T, so revision = expansion"
            : "Proposition contradicts T, so minimal change was needed",
          formal: "If ¬A ∉ T, then T+A = Cn(T ∪ {A})",
        });

        // Consistency: T+A is consistent if A is consistent
        info.push({
          postulate: "(+4) Consistency",
          satisfied: "Yes",
          explanation:
            "The revised theory is consistent because we selected a non-empty set of worlds where the proposition is true",
          formal: "If ¬A is not a tautology, then T+A is consistent",
        });

        // Preservation/Equivalence: If A ≡ B (logically equivalent), then T+A = T+B
        info.push({
          postulate: "(+5) Preservation",
          satisfied: "Yes",
          explanation:
            "Grove's model guarantees that logically equivalent propositions yield identical revisions",
          formal: "If ⊢ A ↔ B, then T+A = T+B",
        });

        // Recovery: (T+A)∩T = T-¬A
        info.push({
          postulate: "(+6) Recovery",
          satisfied: "Yes",
          explanation:
            "The intersection of the revised theory with the original theory equals the contraction of ¬A from T",
          formal: "T ⊆ (T-A)+A",
        });

        // Conjunction 1: T+(A∧B) ⊆ (T+A)+B
        info.push({
          postulate: "(+7) Conjunctive Inclusion",
          satisfied: "Yes",
          explanation:
            "Adding A and B together is contained in adding A then adding B",
          formal: "T+(A∧B) ⊆ (T+A)+B",
        });

        // Conjunction 2: (T+A)+B ⊆ T+(A∧B) when ¬B is not in T+A
        info.push({
          postulate: "(+8) Conjunctive Vacuity",
          satisfied: "Yes",
          explanation:
            "When B is consistent with revision by A, adding B after A equals adding A∧B directly",
          formal: "If ¬B ∉ T+A, then (T+A)+B ⊆ T+(A∧B)",
        });

        return info;
      }

      // Reset the revision process
      function resetRevision() {
        selectedProposition = null;
        revisionResult = null;
        revisionStep = 0;
        draw();
        updateInfo();
      }

      // Update the information panel
      function updateInfo() {
        let html = "";

        if (revisionStep === 0) {
          html =
            "<p>Current theory T is represented by the innermost sphere (|T|).</p>";
          html +=
            "<p>Add propositions and perform revisions to see how Grove's model works.</p>";
        } else if (revisionStep === 1) {
          html = `<p>Revising theory T with proposition ${selectedProposition.name}:</p>`;
          if (revisionResult.sphereIndex === -1) {
            html += `<p>No sphere intersects |${selectedProposition.name}|. This proposition contradicts all possible worlds.</p>`;
          } else {
            html += `<p>The smallest sphere intersecting |${
              selectedProposition.name
            }| is sphere ${revisionResult.sphereIndex + 1}.</p>`;
            html += `<p>This is c(${selectedProposition.name}) in Grove's notation.</p>`;
          }
          html +=
            '<p><button onclick="nextRevisionStep()">Next: Find f<sub>S</sub>(A)</button></p>';
        } else if (revisionStep === 2) {
          html = `<p>Revision of T with ${selectedProposition.name}, step 2:</p>`;
          html += `<p>f<sub>S</sub>(${selectedProposition.name}) = |${selectedProposition.name}| ∩ c(${selectedProposition.name})</p>`;
          html += `<p>These are the "closest" ${selectedProposition.name}-worlds to the current theory T.</p>`;
          html +=
            '<p><button onclick="nextRevisionStep()">Next: Final Result</button></p>';
        } else if (revisionStep === 3) {
          html = `<p>Final result of revising T with ${selectedProposition.name}:</p>`;
          html += `<p>T+${selectedProposition.name} = t(f<sub>S</sub>(${selectedProposition.name}))</p>`;
          html += `<p>The revised theory contains all sentences that are true in all worlds in the highlighted area.</p>`;
        }

        infoContent.innerHTML = html;
      }

      // Advance to the next revision step
      function nextRevisionStep() {
        revisionStep++;
        draw();
        updateInfo();
      }

      // Draw the visualization
      function draw() {
        // Clear canvas
        ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

        // Draw spheres from outside to inside
        for (let i = numSpheres - 1; i >= 0; i--) {
          const radius = (i + 1) * (MAX_RADIUS / numSpheres);
          ctx.beginPath();
          ctx.arc(CENTER_X, CENTER_Y, radius, 0, Math.PI * 2);
          ctx.fillStyle = sphereColors[i];
          ctx.fill();
          ctx.strokeStyle = "rgba(100, 100, 100, 0.3)";
          ctx.stroke();
        }

        // Draw all propositions
        propositions.forEach((prop) => {
          drawProposition(prop);
        });

        // Draw revision highlights
        if (revisionStep > 0 && revisionResult) {
          // Highlight the smallest sphere intersecting the proposition
          if (revisionResult.sphereIndex >= 0) {
            const radius =
              (revisionResult.sphereIndex + 1) * (MAX_RADIUS / numSpheres);
            ctx.beginPath();
            ctx.arc(CENTER_X, CENTER_Y, radius, 0, Math.PI * 2);
            ctx.strokeStyle = "rgba(255, 100, 100, 0.8)";
            ctx.lineWidth = 3;
            ctx.stroke();
            ctx.lineWidth = 1;

            if (revisionStep >= 2) {
              // Highlight the intersection area
              ctx.save();

              // Clip to the sphere
              ctx.beginPath();
              ctx.arc(CENTER_X, CENTER_Y, radius, 0, Math.PI * 2);
              ctx.clip();

              // Draw the proposition with a highlight
              drawProposition(selectedProposition, true);

              ctx.restore();
            }
          }
        }

        // Draw labels
        ctx.fillStyle = "black";
        ctx.font = "14px Arial";
        ctx.textAlign = "center";
        ctx.fillText("|T|", CENTER_X, CENTER_Y);

        // Label for sphere if showing revision
        if (
          revisionStep === 1 &&
          revisionResult &&
          revisionResult.sphereIndex >= 0
        ) {
          const radius =
            (revisionResult.sphereIndex + 1) * (MAX_RADIUS / numSpheres);
          ctx.fillText(
            `c(${selectedProposition.name})`,
            CENTER_X,
            CENTER_Y - radius - 10
          );
        }

        if (
          revisionStep >= 2 &&
          revisionResult &&
          revisionResult.sphereIndex >= 0
        ) {
          const radius =
            (revisionResult.sphereIndex + 1) * (MAX_RADIUS / numSpheres);
          ctx.fillText(
            `f(${selectedProposition.name}) = |${selectedProposition.name}| ∩ c(${selectedProposition.name})`,
            CENTER_X,
            CENTER_Y - radius - 10
          );
        }
      }

      // Draw a proposition
      function drawProposition(prop, highlight = false) {
        ctx.fillStyle = highlight ? "rgba(255, 255, 0, 0.5)" : prop.color;
        ctx.strokeStyle = highlight
          ? "rgba(255, 100, 0, 0.8)"
          : "rgba(0, 0, 0, 0.8)";
        ctx.lineWidth = highlight ? 2 : 1;

        switch (prop.shape) {
          case "circle":
            ctx.beginPath();
            ctx.arc(prop.x, prop.y, prop.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            // Label
            ctx.fillStyle = "black";
            ctx.font = "16px Arial";
            ctx.textAlign = "center";
            ctx.fillText(prop.name, prop.x, prop.y);
            break;

          case "rectangle":
            ctx.beginPath();
            ctx.rect(prop.x, prop.y, prop.width, prop.height);
            ctx.fill();
            ctx.stroke();

            // Label
            ctx.fillStyle = "black";
            ctx.font = "16px Arial";
            ctx.textAlign = "center";
            ctx.fillText(
              prop.name,
              prop.x + prop.width / 2,
              prop.y + prop.height / 2
            );
            break;

          case "polygon":
            ctx.beginPath();
            ctx.moveTo(prop.points[0].x, prop.points[0].y);
            for (let i = 1; i < prop.points.length; i++) {
              ctx.lineTo(prop.points[i].x, prop.points[i].y);
            }
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Calculate centroid for label
            let centroidX = 0,
              centroidY = 0;
            for (const point of prop.points) {
              centroidX += point.x;
              centroidY += point.y;
            }
            centroidX /= prop.points.length;
            centroidY /= prop.points.length;

            // Label
            ctx.fillStyle = "black";
            ctx.font = "16px Arial";
            ctx.textAlign = "center";
            ctx.fillText(prop.name, centroidX, centroidY);
            break;
        }
      }

      // Get a random color
      function getRandomColor() {
        const hue = Math.floor(Math.random() * 360);
        return `hsla(${hue}, 70%, 70%, 0.7)`;
      }

      // Example scenarios
      document
        .getElementById("example-consistency")
        .addEventListener("click", loadConsistencyExample);
      document
        .getElementById("example-minimal-change")
        .addEventListener("click", loadMinimalChangeExample);
      document
        .getElementById("example-success")
        .addEventListener("click", loadSuccessExample);
      document
        .getElementById("example-recovery")
        .addEventListener("click", loadRecoveryExample);
      document
        .getElementById("tutorial-next")
        .addEventListener("click", advanceTutorial);
      document
        .getElementById("tutorial-close")
        .addEventListener("click", closeTutorial);

      let tutorialStep = 0;

      function startTutorial() {
        tutorialStep = 0;
        document.getElementById("tutorial-panel").style.display = "block";
        advanceTutorial();
      }

      function advanceTutorial() {
        const tutorialText = document.getElementById("tutorial-text");
        tutorialStep++;

        switch (tutorialStep) {
          case 1:
            tutorialText.innerHTML =
              "The concentric circles represent Grove's system of spheres. The innermost circle is your current belief set |T|.";
            break;
          case 2:
            tutorialText.innerHTML =
              "Add a proposition by selecting a shape and defining its parameters. This represents some new information.";
            break;
          case 3:
            tutorialText.innerHTML =
              "When you revise with a proposition, we find the smallest sphere intersecting it (c(A)) and take its intersection with the proposition.";
            break;
          case 4:
            tutorialText.innerHTML =
              "The resulting set represents your revised belief T+A, satisfying AGM postulates for rational belief revision.";
            break;
          default:
            closeTutorial();
            break;
        }
      }

      function closeTutorial() {
        document.getElementById("tutorial-panel").style.display = "none";
      }

      function loadConsistencyExample() {
        clearPropositions();
        numSpheres = 4;
        numSpheresInput.value = 4;

        // Create a proposition that intersects with the innermost sphere
        const propA = {
          name: "A",
          shape: "circle",
          x: CENTER_X + MAX_RADIUS * 0.2,
          y: CENTER_Y,
          radius: MAX_RADIUS * 0.4,
          color: "rgba(100, 200, 130, 0.5)",
        };

        propositions.push(propA);
        updatePropositionsList();
        updateRevisionSelect();

        // Set explanation
        infoContent.innerHTML =
          "<p>Proposition A is <strong>consistent</strong> with theory T.</p>" +
          "<p>Notice how A intersects with the innermost sphere |T|.</p>" +
          "<p>When you revise with A, the result will be T∩A (simple expansion), demonstrating AGM postulate (+3).</p>" +
          "<p>Try performing the revision to see this in action.</p>";

        draw();
      }

      function loadMinimalChangeExample() {
        clearPropositions();
        numSpheres = 5;
        numSpheresInput.value = 5;

        // Create a proposition that intersects with the 3rd sphere but not innermost
        const propB = {
          name: "B",
          shape: "circle",
          x: CENTER_X + MAX_RADIUS * 0.6,
          y: CENTER_Y,
          radius: MAX_RADIUS * 0.2,
          color: "rgba(200, 100, 130, 0.5)",
        };

        propositions.push(propB);
        updatePropositionsList();
        updateRevisionSelect();

        // Set explanation
        infoContent.innerHTML =
          "<p>Proposition B is <strong>inconsistent</strong> with theory T.</p>" +
          "<p>Notice B does not intersect with the innermost sphere |T|.</p>" +
          "<p>When revising, Grove's model finds the closest worlds where B is true (minimal change).</p>" +
          "<p>This demonstrates the minimal change principle in AGM postulates (+7/+8).</p>";

        draw();
      }

      function loadSuccessExample() {
        clearPropositions();
        numSpheres = 4;
        numSpheresInput.value = 4;

        // Create proposition C
        const propC = {
          name: "C",
          shape: "rectangle",
          x: CENTER_X - MAX_RADIUS * 0.8,
          y: CENTER_Y - MAX_RADIUS * 0.4,
          width: MAX_RADIUS * 0.5,
          height: MAX_RADIUS * 0.8,
          color: "rgba(130, 130, 230, 0.5)",
        };

        propositions.push(propC);
        updatePropositionsList();
        updateRevisionSelect();

        // Set explanation
        infoContent.innerHTML =
          "<p>Proposition C represents new information we want to accept.</p>" +
          "<p>The Success Postulate (+2) guarantees that after revision with C, the proposition C will be in our belief set.</p>" +
          "<p>Perform the revision to see how Grove's model ensures this by taking worlds from C.</p>";

        draw();
      }

      function loadRecoveryExample() {
        clearPropositions();
        numSpheres = 5;
        numSpheresInput.value = 5;

        // Add two propositions to demonstrate recovery
        const propD = {
          name: "D",
          shape: "circle",
          x: CENTER_X + MAX_RADIUS * 0.4,
          y: CENTER_Y - MAX_RADIUS * 0.3,
          radius: MAX_RADIUS * 0.3,
          color: "rgba(230, 180, 80, 0.5)",
        };

        const propE = {
          name: "E",
          shape: "polygon",
          points: [
            { x: CENTER_X - MAX_RADIUS * 0.5, y: CENTER_Y - MAX_RADIUS * 0.4 },
            { x: CENTER_X - MAX_RADIUS * 0.1, y: CENTER_Y - MAX_RADIUS * 0.1 },
            { x: CENTER_X - MAX_RADIUS * 0.6, y: CENTER_Y + MAX_RADIUS * 0.2 },
          ],
          color: "rgba(80, 180, 230, 0.5)",
        };

        propositions.push(propD);
        propositions.push(propE);
        updatePropositionsList();
        updateRevisionSelect();

        // Set explanation
        infoContent.innerHTML =
          "<p>This example demonstrates how Grove's system handles multiple propositions.</p>" +
          "<p>Try revising first with D, then with E to see how the system maintains coherence.</p>" +
          "<p>Grove's model ensures rational transition between belief states.</p>";

        draw();
      }

      // Enhance the draw function to add better labels
      const originalDraw = draw;
      draw = function () {
        // Call the original draw function
        originalDraw();

        // Add additional labels for spheres
        if (
          canvas.nextSibling &&
          canvas.nextSibling.className === "sphere-label"
        ) {
          while (
            canvas.nextSibling &&
            canvas.nextSibling.className === "sphere-label"
          ) {
            canvas.parentNode.removeChild(canvas.nextSibling);
          }
        }

        // Add labels for each sphere
        for (let i = 0; i < numSpheres; i++) {
          const radius = (i + 1) * (MAX_RADIUS / numSpheres);
          const label = document.createElement("div");
          label.className = "sphere-label";

          if (i === 0) {
            label.textContent = "|T|";
          } else if (
            revisionStep > 0 &&
            revisionResult &&
            revisionResult.sphereIndex === i
          ) {
            label.textContent = `c(${selectedProposition.name})`;
          } else {
            label.textContent = `S${i + 1}`;
          }

          label.style.left = `${CENTER_X + 5}px`;
          label.style.top = `${CENTER_Y - radius - 5}px`;
          canvas.parentNode.insertBefore(label, canvas.nextSibling);
        }

        // Enhanced information for revision visualization
        if (
          revisionStep >= 2 &&
          revisionResult &&
          revisionResult.sphereIndex >= 0
        ) {
          const label = document.createElement("div");
          label.className = "sphere-label";
          label.style.left = `${CENTER_X - 100}px`;
          label.style.top = `${CENTER_Y + MAX_RADIUS + 10}px`;
          label.innerHTML = `<strong>f<sub>S</sub>(${selectedProposition.name}) = |${selectedProposition.name}| ∩ c(${selectedProposition.name})</strong>`;
          canvas.parentNode.insertBefore(label, canvas.nextSibling);
        }
      };

      // Add a button to start the tutorial
      const tutorialButton = document.createElement("button");
      tutorialButton.textContent = "Start Tutorial";
      tutorialButton.style.backgroundColor = "#607d8b";
      tutorialButton.addEventListener("click", startTutorial);
      document.querySelector(".controls").appendChild(tutorialButton);

      // Enhance updateInfo to provide more detailed explanations
      const originalUpdateInfo = updateInfo;
      updateInfo = function () {
        originalUpdateInfo();

        // Add AGM postulate verification when revision is complete
        if (revisionStep === 3 && selectedProposition && revisionResult) {
          const postulateInfo = document.createElement("div");
          postulateInfo.className = "postulate";
          postulateInfo.innerHTML = "<h4>AGM Postulates Satisfied:</h4>";

          const postulatesList = validateAGMPostulates(
            null,
            selectedProposition,
            null
          );

          postulatesList.forEach((p) => {
            postulateInfo.innerHTML += `<p><strong>${p.postulate}:</strong> ${p.explanation}</p>
                                       <p class="math-notation"><em>Formal: ${p.formal}</em></p>`;
          });

          infoContent.appendChild(postulateInfo);
        }
      };

      // Initialize with a welcome message
      window.addEventListener("load", function () {
        infoContent.innerHTML =
          "<h3>Welcome to Grove's System of Spheres Visualization</h3>" +
          "<p>This tool demonstrates Grove's model for belief revision as described in his 1988 paper.</p>" +
          "<p>You can use the controls on the left to:</p>" +
          "<ul>" +
          "<li>Adjust the number of spheres (representing plausibility levels)</li>" +
          "<li>Define propositions as shapes on the plane</li>" +
          "<li>Perform belief revision according to Grove's model</li>" +
          "</ul>" +
          '<p>Try our example scenarios below or click "Start Tutorial" for a guided introduction.</p>';
      });

      // Initialize when the page loads
      window.onload = init;
    </script>
  </body>
</html>
